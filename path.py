from fastapi import APIRouter, Form, HTTPException
from fastapi.responses import JSONResponse
import os
import utils
import json
import subprocess
import chardet
import sys

router = APIRouter()

@router.post("/analyze-paths", summary="分析已保存的Java文件，生成路径图片和路径数据", response_description="返回图片URL和路径数据列表")
async def analyze_paths(sessionId: str = Form(...)):
    if not sessionId:
        raise HTTPException(status_code=400, detail="sessionId为必填！")
    output_dir = os.path.join("results", sessionId)
    code_file = os.path.join(output_dir, "PathAnalysis.java")
    if not os.path.exists(code_file):
        return JSONResponse(status_code=404, content={"error": f"未找到Java文件: {code_file}"})
    # 1. 在 results/{sessionId} 目录下执行 comex，生成所有输出
    try:
        cmd = [
            'comex',
            '--lang', 'java',
            '--code-file', 'PathAnalysis.java',
            '--graphs', 'cfg',
            '--output', 'all'
        ]
        subprocess.run(cmd, check=True, timeout=60, cwd=output_dir)
    except subprocess.CalledProcessError as e:
        return JSONResponse(status_code=500, content={"error": f"comex failed: {str(e)}"})
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": f"comex error: {str(e)}"})
    # 2. 检查输出文件
    img_path = os.path.join(output_dir, "output.png")
    dot_path = os.path.join(output_dir, "output.dot")
    json_path = os.path.join(output_dir, "output.json")
    if not os.path.exists(img_path):
        return JSONResponse(status_code=500, content={"error": "No images generated by comex"})
    if not os.path.exists(dot_path):
        return JSONResponse(status_code=500, content={"error": "No dot file generated by comex"})
    if not os.path.exists(json_path):
        return JSONResponse(status_code=500, content={"error": "No json generated by comex"})
    # 3. 调用extract_paths_and_generate_dot.py脚本进行路径拆解和文件生成
    try:
        result = subprocess.run(
            [sys.executable, '../../extract_paths_and_generate_dot.py'],
            check=True,
            cwd=output_dir,
            capture_output=True,
            text=True
        )
    except subprocess.CalledProcessError as e:
        return JSONResponse(status_code=500, content={"error": f"路径拆解脚本执行失败: {e.stderr or e.stdout or str(e)}"})
    except Exception as e:
        return JSONResponse(status_code=500, content={"error": f"路径拆解脚本执行异常: {str(e)}"})

    # 4. 收集脚本生成的结果文件
    paths_dot_dir = os.path.join(output_dir, 'paths_dot')
    paths_img_dir = os.path.join(output_dir, 'paths_img')
    paths_json_dir = os.path.join(output_dir, 'paths_json')

    pictures_files = sorted([os.path.join('results', sessionId, 'paths_img', f) for f in os.listdir(paths_img_dir) if f.endswith('.png')])
    paths_files = sorted([os.path.join('results', sessionId, 'paths_json', f) for f in os.listdir(paths_json_dir) if f.endswith('.json')])
    dots_files = sorted([os.path.join('results', sessionId, 'paths_dot', f) for f in os.listdir(paths_dot_dir) if f.endswith('.dot')])

    # 5. 组装 paths 信息
    paths = []
    for idx, json_file in enumerate(paths_files):
        with open(os.path.join(paths_json_dir, os.path.basename(json_file)), 'r', encoding='utf-8') as f:
            path_data = json.load(f)
        img_file = pictures_files[idx] if idx < len(pictures_files) else ''
        dot_file = dots_files[idx] if idx < len(dots_files) else ''
        # 尝试获取label顺序
        labels = []
        if isinstance(path_data, dict) and 'nodes' in path_data:
            labels = [n['label'] for n in path_data['nodes']]
        elif isinstance(path_data, list):
            labels = path_data
        paths.append({
            "path_json": json_file,
            "image_url": img_file,
            "dot_file": dot_file,
            "path": ' -> '.join(labels) if labels else ''
        })

    # 6. 将paths信息写入每个paths_json文件
    for path_info in paths:
        json_file = path_info["path_json"]
        json_path = os.path.join(paths_json_dir, os.path.basename(json_file))
        with open(json_path, 'r', encoding='utf-8') as f:
            original_data = json.load(f)
        # 提取 label 顺序
        label_list = path_info["path"].split(" -> ") if path_info["path"] else []
        new_data = {"paths": label_list}
        new_data.update(original_data)
        with open(json_path, 'w', encoding='utf-8') as f:
            json.dump(new_data, f, ensure_ascii=False, indent=2)

    # 6. 返回
    all_image = os.path.relpath(os.path.join(output_dir, "output.png"), '.')
    return {
        "all_image": all_image,
        "paths": paths,
        "pictures_files": pictures_files,
        "paths_files": paths_files,
        "dots_files": dots_files
    }  